# Geth架构

Node服务框架
    Ethereum: 区块链核心组件
    eventMux: 时间发布-订阅
    account.Manager: 账户管理
    RPC服务: http/https,ws/wss,in-proc,ipc
    p2p.Server: 管理所有peer连接和消息分发

Ethereum 区块链核心服务:
    account.Manager: 账户管理
    Miner: 矿工和挖矿管理
    TxPool: 还未上链的交易缓冲池
    EthAPIBackend: 公开的外部操作接口
    chainDB: 区块和链的数据库
    Engine: 共识引擎，支持Pow、PoA
    Blockchain: 区块和链管理
    ProtocolManager: P2P协议层消息收发处理
    ethapi.PublicNetApi: 网络相关的RPC方法

# 交易池（core/txpool/txpool.go）

txpool主要用来存放当前提交的等待写入区块的交易，有远端和本地的。

## txpool主要字段
    pending: 当前等待执行的交易
    queue: 排队但不可执行的交易(比如说nonce太高)，放在queue中等待能够执行
    all: 所有交易
    priced: 所有交易按价格排序

## txpool主要功能
1. 交易验证的功能，包括余额不足，Gas不足，Nonce太低, value值不能为负数。
2. 能够缓存Nonce比当前本地账号状态高的交易，存放在queue字段。如果是能够执行的交易存放在pending字段。
3. 相同用户的相同Nonce的交易只会保留一个GasPrice最大的那个。 其他的插入不成功。
4. 如果账号没有钱了，那么queue和pending中对应账号的交易会被删除。
5. 如果账号的余额小于一些交易额度，那么对应的交易会被删除，同时有效的交易会从pending移动到queue里面，防止被广播。
6. txPool支持一些限制PriceLimit(移除的最低GasPrice限制)，PriceBump(替换相同Nonce的交易的价格的百分比)，AccountSlots(每个账户的pending槽位的最小值)，GlobalSlots(全局pending队列的最大值)，AccountQueue(每个账户的queue槽位的最小值)，GlobalQueue(全局queue的最大值)，Lifetime(在queue队列的最长等待时间)
7. 有限的资源情况下按照GasPrice的优先级进行替换。
8. 本地的交易会使用journal的功能存放在磁盘上，重启之后会重新导入，远程的交易不会。

## txpool流程

### 交易池初始化（core/txpool/txpool.go#NewTxPool）
主要流程：
    读取设置创建交易池
    初始化本地账户并加到交易池
    创建所有交易存储的列表，所有交易的价格用最小堆存放
    重组交易池
    启动重组循环（core/txpool/txpool.go#scheduleReorgLoop）
        满足条件进行交易池重组、广播交易（core/txpool/txpool.go#runReorg）
    如果本地交易开启，从本地磁盘加载本地交易
    从区块链订阅ChainHead事件并开启主事件循环（接收ChainHead并进行交易池重组）

### 添加交易（core/txpool/txpool.go#addTxs）
将本地及远程的交易加入到交易池。
主要流程：
    过滤交易池中已经存在的交易
    将所有新交易加入到queue中（core/txpool/txpool.go#addTxsLocked）
        丢弃已收到过的交易
        校验交易，丢弃校验不通过的
            EIP-2718/2930 之前只支持 Legacy 交易
            EIP-1559 之后支持 dynamic fee 交易
            交易大小不超过 131072
            上海升级后 init code 大小不超过 49152
            交易不能为负
            确保交易不超过当前区块 gas 限制
            对大数进行健全性检查
            gasFeeCap >= gasTipCap
            验证交易签名
            非本地交易在低于能接受的最低 gas 价格或小费时丢弃
            确保交易 nonce 合法
            账户 balance 大于等于 value + gasPrice * gasLimit
            验证加入/替换交易后不会导致透支
            确保交易有比基本交易费用更多的 gas
        如果交易池满了则丢弃低价的交易
        nonce相同，gas更优的交易覆盖旧交易
    如果需要重组交易池，等待重组返回

### 交易升级（core/txpool/txpool.go#promoteExecutables）
将已变得可处理的交易从queue移动到pending。在此过程中，所有无效交易（低nonce、低余额）都将被删除。
主要流程：
    将queue中nonce低于当前账户nonce的交易从all中删除
    将queue中余额不足或gas不足的交易从all中删除
    将所有可执行的交易从queue中移动到pending中（core/txpool/txpool.go#promoteTx）
        如果存在旧交易，判断新交易是否比旧交易好（新交易gas不小于旧交易110%），好则替换并从总花费中移除旧交易花费
        将新交易花费加入到总花费中
    非本地账户的queue超出限制长度，将nonce较大的交易删除
    删除queue为空的账户

### 交易降级（core/txpool/txpool.go#demoteUnexecutables）
发生重组时，所有旧交易（低nonce）将被删除，低余额或高nonce将被移到queue中备用。
主要流程：
    删除所有旧交易（低nonce值）
    放弃所有成本太高的交易（低余额或gas不足），并将交易放回queue中备用
    如果交易前面有间隙（nonce有间隙），将后面的交易移到queue中
    删除pending为空的账户

### 交易重组（core/txpool/txpool.go#reset）

![reset](./txpool_reset.drawio)

## 瓶颈
txpool为了保证数据的一致性使用大量的锁，性能一般。
当区块生成速度比较快的时候需要频繁的reset，导致txpool需要占用比较多的资源

# blockchain（core/blockchain.go）
blockchain主要功能是维护区块链的状态, 包括区块的验证,插入和状态查询。因为在区块的创建过程中,可能在短时间内产生一些分叉, 在数据库里面记录的其实是一颗区块树，会认为其中总难度最高的一条路径是规范的区块链。这样有很多区块虽然也能形成区块链,但是不是规范的区块链。

![blockchain](./blockchain.drawio)

主要流程：
    初始化区块链（core/blockchain.go#NewBlockChain）
        设置创世区块
        初始化验证器、预取器、区块处理器
        从磁盘加载最新状态
        验证区块和状态合法性
        验证区块头数据
        校验是否是预设的坏区块hash值（通常用来硬分叉）
        加载已有快照
        开始处理未来的区块（core/blockchain.go#procFutureBlocks）
            插入区块到链中（core/blockchain.go#InsertChain））
        交易索引构建和删除
    尝试将给定的区块插入到规范链中，或者创建一个分叉（core/blockchain.go#InsertChain）
        健壮性检查：链有序且连贯
        预检通过，开始导入区块（core/blockchain.go#insertChain）
            并行恢复区块签名
            并行验证区块头，调用一致性引擎校验区块头是否合法 （？？查看POW转POS处理）
            修剪块
                第一个块被修剪，作为侧链插入
                合并后父级被修剪，尝试恢复父级状态
                第一个块是未来的，将它和子孙放到未来队列里
                发生其他错误，中止
                循环处理区块
                    如果区块哈希被禁止，直接中止
                    检索父块及其在顶部执行的状态
                    启用预取以在处理的交易时可以拉入trie节点路径
                    使用父状态作为参考点来处理块（core/state_processor.go#Process）
                    验证状态转变后发生的变化是否合法（core/block_validator.go#ValidateState）
                    更新在区块处理和验证过程的统计信息
                    写入区块状态（core/blockchain.go#writeBlockWithState或者core/blockchain.go#writeBlockAndSetHead）
                        将块、元数据和相应的状态数据写入数据库（core/blockchain.go#writeBlockWithState）
                        将块、元数据和相应的状态数据写入数据库，并设置头部区块（core/blockchain.go#writeBlockAndSetHead）
                    更新在区块提交过程的统计信息
                    打印统计信息
