Node服务框架
    Ethereum: 区块链核心组件
    eventMux: 时间发布-订阅
    account.Manager: 账户管理
    RPC服务: http/https,ws/wss,in-proc,ipc
    p2p.Server: 管理所有peer连接和消息分发

Ethereum 区块链核心服务:
    account.Manager: 账户管理
    Miner: 矿工和挖矿管理
    TxPool: 还未上链的交易缓冲池
    EthAPIBackend: 公开的外部操作接口
    chainDB: 区块和链的数据库
    Engine: 共识引擎，支持Pow、PoA
    Blockchain: 区块和链管理
    ProtocolManager: P2P协议层消息收发处理
    ethapi.PublicNetApi: 网络相关的RPC方法



# 交易池（core/txpool/txpool.go）

txpool主要用来存放当前提交的等待写入区块的交易，有远端和本地的。

## 分类
txpool里面的交易分为两种，
    queue: 提交但是还不能执行的(如nonce值过大)
    pending: 等待执行的

## txpool主要功能
1. 交易验证的功能，包括余额不足，Gas不足，Nonce太低, value值是合法的，不能为负数。
2. 能够缓存Nonce比当前本地账号状态高的交易。 存放在queue字段。 如果是能够执行的交易存放在pending字段
3. 相同用户的相同Nonce的交易只会保留一个GasPrice最大的那个。 其他的插入不成功。
4. 如果账号没有钱了，那么queue和pending中对应账号的交易会被删除。
5. 如果账号的余额小于一些交易的额度，那么对应的交易会被删除，同时有效的交易会从pending移动到queue里面。防止被广播。
6. txPool支持一些限制PriceLimit(remove的最低GasPrice限制)，PriceBump(替换相同Nonce的交易的价格的百分比) AccountSlots(每个账户的pending的槽位的最小值) GlobalSlots(全局pending队列的最大值) AccountQueue(每个账户的queueing的槽位的最小值) GlobalQueue(全局queueing的最大值) Lifetime(在queue队列的最长等待时间)
7. 有限的资源情况下按照GasPrice的优先级进行替换。
8. 本地的交易会使用journal的功能存放在磁盘上，重启之后会重新导入。 远程的交易不会。


### 交易池初始化（core/txpool/txpool.go#NewTxPool）
主要流程：
    读取设置创建交易池
    初始化本地账户并加到交易池
    创建所有交易存储的列表，所有交易的价格用最小堆存放
    重组交易池
    启动重组循环
    如果本地交易开启，从本地磁盘加载本地交易
    从区块链订阅ChainHead事件
    开启主循环

### 添加交易
主要流程：
    过滤交易池中已经存在的交易
    将所有新交易加入到queue中（core/txpool/txpool.go#addTxsLocked）
        丢弃已收到过的交易
        校验交易，丢弃校验不通过的
            EIP-2718/2930 之前只支持 Legacy 交易
            EIP-1559 之后支持 dynamic fee 交易
            交易大小不超过 131072
            上海升级后 init code 大小不超过 49152
            交易不能为负
            确保交易不超过当前区块 gas 限制
            对大数进行健全性检查
            gasFeeCap >= gasTipCap
            验证交易签名
            非本地交易在低于能接受的最低 gas 价格或小费时丢弃
            确保交易 nonce 合法
            账户 balance 大于等于 value + gasPrice * gasLimit
            验证加入/替换交易后不会导致透支
            确保交易有比基本交易费用更多的 gas
        如果交易池满了则丢弃低价的交易
        nonce相同，gas更优的交易覆盖旧交易

### 交易升级（core/txpool/txpool.go#promoteExecutables）
将已变得可处理的交易从queue移动到pending。在此过程中，所有无效交易（低随机数、低余额）都将被删除
主要流程：
    将queue中nonce低于当前账户nonce的交易从all中删除
    将queue中余额不足或gas不足的交易从all中删除
    将所有可执行的交易从queue中移动到pending中（core/txpool/txpool.go#promoteTx）
        如果存在旧交易，判断新交易是否比旧交易好（新交易gas不小于旧交易110%），好则替换并从总花费中移除旧交易花费
        将新交易花费加入到总花费中
    非本地账户的queue超出限制长度，将nonce较大的交易删除
    删除queue为空的账户

### 交易降级（core/txpool/txpool.go#demoteUnexecutables）
主要流程：
    删除所有旧交易（低nonce值）
    放弃所有成本太高的交易（低余额或gas不足），并将交易放回queue中备用
    如果交易前面有间隙（nonce有间隙），将后面的交易移到queue中
    删除pending为空的账户

### 交易重组（core/txpool/txpool.go#reset）

![flow](./txpool_reset.drawio)

思考
以太坊在实现TXpool的时候为了保证数据的一致性使用大量的锁，性能一般
当区块生成速度比较快的时候需要频繁的reset，导致TXpool需要占用比较多的资源
是否有比较好的方法既可以保证数据的一致性又可以快速找到相同的根区块？

# blockchain（core/blockchain.go）
blockchain主要功能是维护区块链的状态, 包括区块的验证,插入和状态查询。
主要流程：
    初始化区块链（core/blockchain.go#NewBlockChain）
        设置创世区块
        初始化验证器、预取器、区块处理器
        从磁盘加载最新状态
        验证区块和状态合法性
        验证区块头数据
        校验是否是预设的坏区块hash值（通常用来硬分叉）
        加载已有快照
        开始处理未来的区块（core/blockchain.go#procFutureBlocks）
            插入区块到链中（core/blockchain.go#InsertChain））
        交易索引构建和删除
    尝试将给定的区块插入到规范链中，或者创建一个分叉（core/blockchain.go#InsertChain）
        健壮性检查：链有序且连贯
        预检通过，开始导入区块（core/blockchain.go#insertChain）
            并行恢复区块签名
            并行验证区块头，调用一致性引擎校验区块头是否合法 （？？查看POW转POS处理）
            修剪块
                第一个块被修剪，作为侧链插入
                合并后父级被修剪，尝试恢复父级状态
                第一个块是未来的，将它和子孙放到未来队列里
                发生其他错误，中止
                循环处理区块
                    如果区块哈希被禁止，直接中止
                    检索父块及其在顶部执行的状态
                    启用预取以在处理的交易时可以拉入trie节点路径
                    使用父状态作为参考点来处理块（core/state_processor.go#Process）
                    验证状态转变后发生的变化是否合法（core/block_validator.go#ValidateState）
                    更新在区块处理和验证过程的统计信息
                    写入区块状态（core/blockchain.go#writeBlockWithState或者core/blockchain.go#writeBlockAndSetHead）
                        将块、元数据和相应的状态数据写入数据库（core/blockchain.go#writeBlockWithState）
                        将块、元数据和相应的状态数据写入数据库，并设置头部区块（core/blockchain.go#writeBlockAndSetHead）
                    更新在区块提交过程的统计信息
                    打印统计信息

# state

![state](assets/02/state.png)

蓝色的矩形代表本模块
    database主要提供了trie树的抽象，提供trie树的缓存和合约代码长度的缓存。
    journal主要提供了操作日志，以及操作回滚的功能。
    state_object是account对象的抽象，提供了账户的一些功能。
    statedb主要是提供了state trie的部分功能。

core/state_processor.go#Process（？？static call和call区别）

# bloom
eth/bloombits.go
